colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 3
# evaluate 1
knn.predicted1 <- knn(set1$training, set1$testing, training$age.group, k)
table(knn.predicted1, abalone.data$age.group, dnn=list('predicted','actual'))
# evaluate 2
knn.predicted2 <- knn(set2$training, set2$testing, training$age.group, k)
table(knn.predicted2, abalone.data$age.group, dnn=list('predicted','actual'))
install.packages("class")
library("class")
# read dataset
abalone.data <- read.table("C:/Users/liggea/Documents/GitHub/data-analytics-s26/Lab 3/abalone/abalone.data", header=FALSE, sep=',')
colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 3
# evaluate 1
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = k)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
# evaluate 2
knn.predicted2 <- knn(train = set2$training,
test  = set2$test,
cl    = training$age.group,
k     = k)
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
####################################
##### Abalone Data Preparation #####
####################################
install.packages("class")
# read dataset
abalone.data <- read.table("C:/Users/liggea/Documents/GitHub/data-analytics-s26/Lab 3/abalone/abalone.data", header=FALSE, sep=',')
colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 4
# evaluate 1
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = k)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
# evaluate 2
knn.predicted2 <- knn(train = set2$training,
test  = set2$test,
cl    = training$age.group,
k     = k)
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
# read dataset
abalone.data <- read.table("C:/Users/liggea/Documents/GitHub/data-analytics-s26/Lab 3/abalone/abalone.data", header=FALSE, sep=',')
colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 3
# evaluate 1
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = k)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
# evaluate 2
knn.predicted2 <- knn(train = set2$training,
test  = set2$test,
cl    = training$age.group,
k     = k)
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
# read dataset
abalone.data <- read.table("C:/Users/liggea/Documents/GitHub/data-analytics-s26/Lab 3/abalone/abalone.data", header=FALSE, sep=',')
colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 2
# evaluate 1
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = k)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
# evaluate 2
knn.predicted2 <- knn(train = set2$training,
test  = set2$test,
cl    = training$age.group,
k     = k)
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
# read dataset
abalone.data <- read.table("C:/Users/liggea/Documents/GitHub/data-analytics-s26/Lab 3/abalone/abalone.data", header=FALSE, sep=',')
colnames(abalone.data) = c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")
## add new column age.group with 3 values based on the number of rings
abalone.data$age.group <- cut(abalone.data$rings, br=c(0,8,11,35), labels = c("young", 'adult', 'old'))
## alternative way of setting age.group
abalone.data$age.group[abalone.data$rings<=8] <- "young"
abalone.data$age.group[abalone.data$rings>8 & abalone.data$rings<=11] <- "adult"
abalone.data$age.group[abalone.data$rings>11 & abalone.data$rings<=35] <- "old"
set.seed(2026)
train.index <- sample(1:nrow(abalone.data), 0.7 * nrow(abalone.data))
training <- abalone.data[train.index, ]
testing <- abalone.data[-train.index, ]
uno = c("length", "diameter", "height", "rings")
dos = c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
normalize <- function(training, testing, featureset) {
training.scaled <- scale(training[, featureset])
testing.scaled <- scale(testing[, featureset], center=attr(training.scaled, "scaled:center"), scale=attr(training.scaled, "scaled:scale"))
list(training=training.scaled, test=testing.scaled)
}
set1 <- normalize(training, testing, uno)
set2 <- normalize(training, testing, dos)
k <- 1
# evaluate 1
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = k)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
# evaluate 2
knn.predicted2 <- knn(train = set2$training,
test  = set2$test,
cl    = training$age.group,
k     = k)
table(knn.predicted2, testing$age.group,
dnn = c("predicted","actual"))
# 1 is clearly better, find an ideal k value
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
}
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual"))
}
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
# 1 is clearly better, find an ideal k value
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
}
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print("k = ", superk, ":")
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
}
# 1 is clearly better, find an ideal k value
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print("k = " + superk + ":")
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
}
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print("k = ")
print(superk)
print(":")
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
}
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print(superk)
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
}
# 1 is clearly better, find an ideal k value
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
print(superk)
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
print(round(correct / total, 4))
}
for (superk in 1:10) {
knn.predicted1 <- knn(train = set1$training,
test  = set1$test,
cl    = training$age.group,
k     = superk)
correct <- sum(knn.predicted1 == testing$age.group)
total <- length(testing$age.group)
print(superk)
print(table(knn.predicted1, testing$age.group,
dnn = c("predicted","actual")))
print(round(correct / total, 4))
}
library("class")
install.packages("cluster")
library("cluster")
# part 2: k-means/PAM
cluster.data <- scaled(abalone.data[, c("length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")])
# part 2: k-means/PAM
cluster.data <- scale(abalone.data[, c("length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings")])
# k-means first
silhouette_widths = numeric(10)
for (k in 1:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
silhouette_widths[i] = mean(sil[, 3])
}
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
str(sil)
# k-means first
silhouette_widths = numeric(10)
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
str(sil)
silhouette_widths[k] = mean(sil[, 3])
}
plot(1:10, silhouette_widths, type = "b", xlab="clusters", ylab="avg. silhouette width")
# k-means first
silhouette_widths = numeric(10)
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
silhouette_widths[k] = mean(sil[, 3])
}
plot(1:10, silhouette_widths, type = "b", xlab="clusters", ylab="avg. silhouette width")
# k-means first
k.best <- 0
width.best <- 1
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width < width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
# k-means first
k.best <- 0
width.best <- 0
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.best_result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
plot(sil)
k.best <- k
width.best <- width
if(width > width.best) {
k.best <- k
width.best <- width
}
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
plot(sil)
plot(sil)
k.best <- k
width.best <- width
if(width > width.best) {
k.best <- k
width.best <- width
}
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
plot(sil, main = paste("Silhouette plot for k = ", best_k), col = rainbow(best_k))
width.best <- width
if(width > width.best) {
k.best <- k
width.best <- width
}
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
plot(sil, main = paste("Silhouette plot for k = ", k.best), col = rainbow(k.best))
## plot wcss vs. k
plot(k.list,wcss.list,type = "b")
## plot avg silhouette width vs. k
plot(k.list[-1],si.list,type = "b")
###################################
##### Clustering with Iris v3 #####
###################################
## imports
library(GGally)
install.packages(GGally)
install.packages('GGally')
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
fviz_silhouette(sil) +
ggtitle(paste("Silhouette Plot for k =", k.best)) +
theme_minimal()
install.packages("class")
library("cluster")
install.packages("factoextra")
library("factoextra")
k.best <- 0
width.best <- 0
for (k in 2:10) {
kmeans.result = kmeans(cluster.data, centers = k, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
width = mean(sil[, 3])
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
kmeans.result <- kmeans(cluster.data, centers = k.best, nstart = 25)
sil <- silhouette(kmeans.result$cluster, dist(cluster.data))
fviz_silhouette(sil) +
ggtitle(paste("Silhouette Plot for k =", k.best)) +
theme_minimal()
fviz_silhouette(sil)
# PAM
k.best <- 0
width.best <- 0
for (k in 2:10) {
pam.result = pam(cluster.data, k = k)
width <- pam.result$silinfo$avg.width
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
pam.result = pam(cluster.data, k = k)
fviz_silhouette(pam.result)
# PAM
k.best <- 0
width.best <- 0
for (k in 2:10) {
pam.result = pam(cluster.data, k = k)
width <- pam.result$silinfo$avg.width
if(width > width.best) {
k.best <- k
width.best <- width
}
}
print(k.best)
pam.result = pam(cluster.data, k = k.best)
fviz_silhouette(pam.result)
